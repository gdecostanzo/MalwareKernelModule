#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/types.h>
#include <linux/unistd.h>
#include <asm/cacheflush.h>
#include <asm/page.h>
#include <asm/current.h>
#include <linux/sched.h>
#include <linux/kallsyms.h>
#include <crypto/internal/hash.h>
#include <linux/fs.h>
#include <asm/segment.h>
#include <linux/buffer_head.h>
#include <asm/uaccess.h>
#include <linux/un.h>
#include <linux/net.h>
#include <net/sock.h>
#include <linux/socket.h>

#define SOCK_PATH   "/tmp/usocket"
#define MAX     10
#define SHA256_LENGTH (256/8) 

unsigned long *syscall_table = (unsigned long *)0xffffffff81801300;

static void  get_printable_hash(char * hash_sha256, char * str)
{
    int i;
    for (i = 0; i < SHA256_LENGTH ; i++)
        sprintf(&str[i*2],"%02x", (unsigned char)hash_sha256[i]);
    str[i*2] = 0;
}

struct file *file_open(const char *path, int flags, int rights) 
{
    struct file *filp = NULL;
    mm_segment_t oldfs;
    int err = 0;

    oldfs = get_fs();
    set_fs(get_ds());
    filp = filp_open(path, flags, rights);
    set_fs(oldfs);
    if (IS_ERR(filp)) {
        err = PTR_ERR(filp);
        return NULL;
    }
    return filp;
}

void file_close(struct file *file) 
{
    filp_close(file, NULL);
}

int file_read(struct file *file, unsigned long long offset, unsigned char *data, unsigned int size) 
{
    mm_segment_t oldfs;
    int ret;

    oldfs = get_fs();
    set_fs(get_ds());

    ret = vfs_read(file, data, size, &offset);

    set_fs(oldfs);
    return ret;
}

//connection with Python module for DHT
int check_DHT(const char *hash)
{
	struct socket *sock = NULL;	
	int retval;
	char return_msg[MAX];

	struct sockaddr_un addr;
	struct msghdr msg;
	struct iovec iov;
	mm_segment_t oldfs;

	// create socket
	retval = sock_create(AF_UNIX, SOCK_STREAM, 0, &sock);
	
	// connect
	memset(&addr, 0, sizeof(addr));  
	addr.sun_family = AF_UNIX;
	strcpy(addr.sun_path, SOCK_PATH);
	retval = sock->ops->connect(sock, (struct sockaddr *)&addr, sizeof(addr), 0);
	
	memset(&msg, 0, sizeof(msg));
	memset(&iov, 0, sizeof(iov));

	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_iov->iov_base= hash;
	msg.msg_iov->iov_len= strlen(hash)+1;
	msg.msg_control = NULL;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;

	oldfs = get_fs();
	set_fs(KERNEL_DS);
	
	//sending hash 
	retval = sock_sendmsg(sock, &msg, strlen(hash)+1);
	
	//changing string buffer in msg header for recvmsg
	msg.msg_iov->iov_base= return_msg;
	msg.msg_iov->iov_len= MAX;
	
	//receive_msg	
	retval = sock_recvmsg(sock, &msg, MAX, 0);
	
	set_fs(oldfs);

  	// release socket
  	sock_release(sock);
	
	return (return_msg[0]=='1');
	
}   


int check_SHA256_hash(const char *filename)
{
	struct file *file;
	struct kstat stat;
	
	mm_segment_t old_fs = get_fs();
	set_fs(KERNEL_DS);
	int err;
	err= vfs_stat(filename, &stat);
	set_fs(old_fs);
	
	unsigned long file_size;
	file_size = (unsigned long) stat.size;

	file = file_open(filename, O_RDONLY, 0);
	char *plaintext = kmalloc(file_size, GFP_KERNEL);		
	file_read(file, 0, plaintext, file_size);
	file_close(file);

	char hash_sha256[SHA256_LENGTH];
	struct crypto_shash *sha256;
	struct shash_desc *shash;

	sha256 = crypto_alloc_shash("sha256", 0, 0);
	if (IS_ERR(sha256))
		return -1;

	shash =
		kmalloc(sizeof(struct shash_desc) + crypto_shash_descsize(sha256),
			GFP_KERNEL);
	if (!shash)
		return -ENOMEM;

	shash->tfm = sha256;
	shash->flags = 0;

	if (crypto_shash_init(shash))
		return -1;

	if (crypto_shash_update(shash, plaintext, file_size))
		return -1;

	if (crypto_shash_final(shash, hash_sha256))
		return -1;

	kfree(shash);
	kfree(plaintext);

	crypto_free_shash(sha256);
	
	char hash_str[SHA256_LENGTH*2 + 1];
	get_printable_hash(hash_sha256, hash_str);
	printk(KERN_ALERT "sha digest: %s", hash_str);
		
	if(!check_DHT(hash_str)){
		printk(KERN_ALERT "BAD HASH!");
		return -1;
	}
	
	return 0;
}

asmlinkage int (*original_execve)(const char *, const char *[], const char *[]);

asmlinkage int new_execve(const char *filename, const char *argv[], const char *envp[]) {
	//hijacked execve
	
	printk(KERN_ALERT "EXECUTING: %s", filename);
	if(check_SHA256_hash(filename) == 0)
		return (*original_execve)(filename, argv, envp);
	else
		return NULL;
}

static int init(void) {

    printk(KERN_ALERT "\nHIJACK INIT\n");

    write_cr0 (read_cr0 () & (~ 0x10000));

    original_execve = (void *)syscall_table[__NR_execve];
    syscall_table[__NR_execve] = new_execve;

    write_cr0 (read_cr0 () | 0x10000);

    return 0;
}

static void exit(void) {

    write_cr0 (read_cr0 () & (~ 0x10000));

    syscall_table[__NR_execve] = original_execve;

    write_cr0 (read_cr0 () | 0x10000);

    printk(KERN_ALERT "MODULE EXIT\n");

    return;
}


module_init(init);
module_exit(exit);
MODULE_LICENSE("GPL");
